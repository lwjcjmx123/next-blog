---
title: "ååŒå¼€å‘ä¸ç‰ˆæœ¬æ§åˆ¶ï¼šç¼–è¾‘é”å®šä¸å¯è§†åŒ–å·®å¼‚ç³»ç»Ÿ"
slug: "collaborative-development-system"
excerpt: "è®¾è®¡å®ç°åŸºäºGitçš„ååŒå¼€å‘ç³»ç»Ÿï¼Œæ”¯æŒç¼–è¾‘é”å®šå’Œå¯è§†åŒ–å·®å¼‚å¯¹æ¯”"
published: true
date: "2024-01-18"
category: "å¼€å‘å·¥å…·"
tags: ["ååŒå¼€å‘", "ç‰ˆæœ¬æ§åˆ¶", "Git", "ç¼–è¾‘é”å®š", "å¯è§†åŒ–å·®å¼‚"]
author: "Long"
readingTime: "10åˆ†é’Ÿ"
---

## æ¦‚è¿°

åœ¨å¤šäººååŒå¼€å‘åœºæ™¯ä¸­ï¼Œå¦‚ä½•é¿å…ç¼–è¾‘å†²çªã€å®ç°å®æ—¶åä½œå’Œç‰ˆæœ¬ç®¡ç†æ˜¯å…³é”®æŒ‘æˆ˜ã€‚æœ¬æ–‡ä»‹ç»ä¸€å¥—åŸºäº Git çš„ååŒå¼€å‘ç³»ç»Ÿï¼Œé€šè¿‡ç¼–è¾‘é”å®šæœºåˆ¶å’Œå¯è§†åŒ–å·®å¼‚å·¥å…·ï¼Œæå‡å›¢é˜Ÿå¼€å‘æ•ˆç‡ã€‚

## ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶

<ArchitectureDiagram 
  title="ååŒå¼€å‘ç³»ç»Ÿæ¶æ„"
  layers={[
    {
      name: "å‰ç«¯ç¼–è¾‘å™¨",
      color: "#3b82f6",
      components: ["Monaco Editor", "ä»£ç ç¼–è¾‘", "å®æ—¶åä½œ", "è¯­æ³•é«˜äº®"]
    },
    {
      name: "ååŒæœåŠ¡å±‚",
      color: "#8b5cf6",
      components: ["WebSocketé€šä¿¡", "Redisç¼“å­˜", "ç¼–è¾‘é”å®š", "å†²çªæ£€æµ‹"]
    },
    {
      name: "ç‰ˆæœ¬æ§åˆ¶å±‚",
      color: "#10b981",
      components: ["Gitä»“åº“", "åˆ†æ”¯ç®¡ç†", "æäº¤å†å²", "åˆå¹¶ç­–ç•¥"]
    },
    {
      name: "å·®å¼‚å¼•æ“",
      color: "#f59e0b",
      components: ["Myersç®—æ³•", "ASTè§£æ", "å¯è§†åŒ–å±•ç¤º", "å·®å¼‚å¯¹æ¯”"]
    }
  ]}
/>

### æŠ€æœ¯æ ˆ

- **å‰ç«¯**: Monaco Editor + WebSocket
- **åç«¯**: Node.js + Express + Socket.io
- **å­˜å‚¨**: Redis + Git
- **å·®å¼‚ç®—æ³•**: Myers ç®—æ³• + AST è§£æ

## ç¼–è¾‘é”å®šç³»ç»Ÿ

### é”å®šç®¡ç†å™¨

```javascript
// LockManager.js
class LockManager {
  constructor(redisClient) {
    this.redis = redisClient;
    this.lockPrefix = "edit_lock:";
    this.lockTimeout = 30 * 60 * 1000; // 30åˆ†é’Ÿè¶…æ—¶
  }

  /**
   * è·å–ç¼–è¾‘é”
   */
  async acquireLock(fileId, userId, userInfo) {
    const lockKey = `${this.lockPrefix}${fileId}`;
    const lockData = {
      userId,
      userInfo,
      timestamp: Date.now(),
      heartbeat: Date.now(),
    };

    try {
      // æ£€æŸ¥æ˜¯å¦å·²è¢«é”å®š
      const existingLock = await this.redis.get(lockKey);

      if (existingLock) {
        const lock = JSON.parse(existingLock);

        // æ£€æŸ¥é”æ˜¯å¦è¿‡æœŸ
        if (Date.now() - lock.heartbeat > this.lockTimeout) {
          await this.releaseLock(fileId);
        } else if (lock.userId !== userId) {
          throw new Error(`æ–‡ä»¶æ­£åœ¨è¢« ${lock.userInfo.name} ç¼–è¾‘`);
        }
      }

      // è®¾ç½®é”å®š
      await this.redis.setex(
        lockKey,
        this.lockTimeout / 1000,
        JSON.stringify(lockData)
      );

      return {
        success: true,
        lockId: `${fileId}_${userId}_${Date.now()}`,
      };
    } catch (error) {
      throw new Error(`è·å–ç¼–è¾‘é”å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * é‡Šæ”¾ç¼–è¾‘é”
   */
  async releaseLock(fileId, userId = null) {
    const lockKey = `${this.lockPrefix}${fileId}`;

    try {
      if (userId) {
        // éªŒè¯ç”¨æˆ·æƒé™
        const existingLock = await this.redis.get(lockKey);
        if (existingLock) {
          const lock = JSON.parse(existingLock);
          if (lock.userId !== userId) {
            throw new Error("æ— æƒé™é‡Šæ”¾æ­¤é”");
          }
        }
      }

      await this.redis.del(lockKey);
      return { success: true };
    } catch (error) {
      throw new Error(`é‡Šæ”¾ç¼–è¾‘é”å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * å¿ƒè·³ä¿æŒ
   */
  async heartbeat(fileId, userId) {
    const lockKey = `${this.lockPrefix}${fileId}`;

    try {
      const existingLock = await this.redis.get(lockKey);

      if (existingLock) {
        const lock = JSON.parse(existingLock);

        if (lock.userId === userId) {
          lock.heartbeat = Date.now();
          await this.redis.setex(
            lockKey,
            this.lockTimeout / 1000,
            JSON.stringify(lock)
          );
          return { success: true };
        }
      }

      throw new Error("é”ä¸å­˜åœ¨æˆ–æ— æƒé™");
    } catch (error) {
      throw new Error(`å¿ƒè·³æ›´æ–°å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * è·å–é”çŠ¶æ€
   */
  async getLockStatus(fileId) {
    const lockKey = `${this.lockPrefix}${fileId}`;

    try {
      const lockData = await this.redis.get(lockKey);

      if (!lockData) {
        return { locked: false };
      }

      const lock = JSON.parse(lockData);

      // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
      if (Date.now() - lock.heartbeat > this.lockTimeout) {
        await this.releaseLock(fileId);
        return { locked: false };
      }

      return {
        locked: true,
        userId: lock.userId,
        userInfo: lock.userInfo,
        timestamp: lock.timestamp,
      };
    } catch (error) {
      console.error("è·å–é”çŠ¶æ€å¤±è´¥:", error);
      return { locked: false };
    }
  }
}

export default LockManager;
```

### ååŒç¼–è¾‘æœåŠ¡

```javascript
// CollaborationService.js
import { Server } from "socket.io";
import LockManager from "./LockManager.js";
import GitManager from "./GitManager.js";

class CollaborationService {
  constructor(server, redisClient) {
    this.io = new Server(server, {
      cors: {
        origin: "*",
        methods: ["GET", "POST"],
      },
    });

    this.lockManager = new LockManager(redisClient);
    this.gitManager = new GitManager();
    this.activeUsers = new Map();

    this.setupSocketHandlers();
  }

  setupSocketHandlers() {
    this.io.on("connection", (socket) => {
      console.log(`ç”¨æˆ·è¿æ¥: ${socket.id}`);

      // ç”¨æˆ·åŠ å…¥æ–‡ä»¶ç¼–è¾‘
      socket.on("join-file", async (data) => {
        try {
          const { fileId, userId, userInfo } = data;

          // åŠ å…¥æˆ¿é—´
          socket.join(fileId);

          // è®°å½•æ´»è·ƒç”¨æˆ·
          this.activeUsers.set(socket.id, {
            fileId,
            userId,
            userInfo,
            joinTime: Date.now(),
          });

          // è·å–é”çŠ¶æ€
          const lockStatus = await this.lockManager.getLockStatus(fileId);

          // é€šçŸ¥å…¶ä»–ç”¨æˆ·
          socket.to(fileId).emit("user-joined", {
            userId,
            userInfo,
            lockStatus,
          });

          // å‘é€å½“å‰çŠ¶æ€
          socket.emit("join-success", {
            lockStatus,
            activeUsers: this.getFileActiveUsers(fileId),
          });
        } catch (error) {
          socket.emit("error", { message: error.message });
        }
      });

      // è¯·æ±‚ç¼–è¾‘é”
      socket.on("request-lock", async (data) => {
        try {
          const { fileId, userId, userInfo } = data;

          const result = await this.lockManager.acquireLock(
            fileId,
            userId,
            userInfo
          );

          if (result.success) {
            // é€šçŸ¥æ‰€æœ‰ç”¨æˆ·é”çŠ¶æ€å˜æ›´
            this.io.to(fileId).emit("lock-acquired", {
              userId,
              userInfo,
              lockId: result.lockId,
            });

            socket.emit("lock-success", result);
          }
        } catch (error) {
          socket.emit("lock-error", { message: error.message });
        }
      });

      // é‡Šæ”¾ç¼–è¾‘é”
      socket.on("release-lock", async (data) => {
        try {
          const { fileId, userId } = data;

          await this.lockManager.releaseLock(fileId, userId);

          // é€šçŸ¥æ‰€æœ‰ç”¨æˆ·
          this.io.to(fileId).emit("lock-released", {
            userId,
            fileId,
          });
        } catch (error) {
          socket.emit("error", { message: error.message });
        }
      });

      // å†…å®¹å˜æ›´
      socket.on("content-change", async (data) => {
        try {
          const { fileId, userId, changes, version } = data;

          // éªŒè¯ç¼–è¾‘æƒé™
          const lockStatus = await this.lockManager.getLockStatus(fileId);

          if (!lockStatus.locked || lockStatus.userId !== userId) {
            socket.emit("error", { message: "æ— ç¼–è¾‘æƒé™" });
            return;
          }

          // å¹¿æ’­å˜æ›´ï¼ˆé™¤äº†å‘é€è€…ï¼‰
          socket.to(fileId).emit("content-updated", {
            userId,
            changes,
            version,
            timestamp: Date.now(),
          });

          // å¿ƒè·³ä¿æŒ
          await this.lockManager.heartbeat(fileId, userId);
        } catch (error) {
          socket.emit("error", { message: error.message });
        }
      });

      // ä¿å­˜æ–‡ä»¶
      socket.on("save-file", async (data) => {
        try {
          const { fileId, userId, content, message } = data;

          // éªŒè¯ç¼–è¾‘æƒé™
          const lockStatus = await this.lockManager.getLockStatus(fileId);

          if (!lockStatus.locked || lockStatus.userId !== userId) {
            socket.emit("error", { message: "æ— ç¼–è¾‘æƒé™" });
            return;
          }

          // Gitæäº¤
          const commitResult = await this.gitManager.commitFile(
            fileId,
            content,
            message,
            userId
          );

          // é€šçŸ¥ä¿å­˜æˆåŠŸ
          this.io.to(fileId).emit("file-saved", {
            userId,
            commitHash: commitResult.hash,
            timestamp: Date.now(),
          });
        } catch (error) {
          socket.emit("save-error", { message: error.message });
        }
      });

      // æ–­å¼€è¿æ¥
      socket.on("disconnect", async () => {
        const userInfo = this.activeUsers.get(socket.id);

        if (userInfo) {
          const { fileId, userId } = userInfo;

          // é‡Šæ”¾å¯èƒ½æŒæœ‰çš„é”
          try {
            await this.lockManager.releaseLock(fileId, userId);

            // é€šçŸ¥å…¶ä»–ç”¨æˆ·
            socket.to(fileId).emit("user-left", {
              userId,
              lockReleased: true,
            });
          } catch (error) {
            console.error("æ–­å¼€è¿æ¥æ—¶é‡Šæ”¾é”å¤±è´¥:", error);
          }

          this.activeUsers.delete(socket.id);
        }

        console.log(`ç”¨æˆ·æ–­å¼€è¿æ¥: ${socket.id}`);
      });
    });
  }

  /**
   * è·å–æ–‡ä»¶çš„æ´»è·ƒç”¨æˆ·
   */
  getFileActiveUsers(fileId) {
    const users = [];

    for (const [socketId, userInfo] of this.activeUsers) {
      if (userInfo.fileId === fileId) {
        users.push({
          socketId,
          userId: userInfo.userId,
          userInfo: userInfo.userInfo,
          joinTime: userInfo.joinTime,
        });
      }
    }

    return users;
  }
}

export default CollaborationService;
```

## Git ç‰ˆæœ¬æ§åˆ¶

### Git ç®¡ç†å™¨

```javascript
// GitManager.js
import { execSync } from "child_process";
import fs from "fs/promises";
import path from "path";

class GitManager {
  constructor(repoPath = "./workspace") {
    this.repoPath = repoPath;
    this.initRepo();
  }

  /**
   * åˆå§‹åŒ–Gitä»“åº“
   */
  async initRepo() {
    try {
      await fs.access(path.join(this.repoPath, ".git"));
    } catch {
      // ä»“åº“ä¸å­˜åœ¨ï¼Œåˆå§‹åŒ–
      execSync("git init", { cwd: this.repoPath });
      execSync('git config user.name "Collaboration System"', {
        cwd: this.repoPath,
      });
      execSync('git config user.email "system@example.com"', {
        cwd: this.repoPath,
      });
    }
  }

  /**
   * æäº¤æ–‡ä»¶
   */
  async commitFile(fileId, content, message, userId) {
    try {
      const filePath = path.join(this.repoPath, fileId);

      // ç¡®ä¿ç›®å½•å­˜åœ¨
      await fs.mkdir(path.dirname(filePath), { recursive: true });

      // å†™å…¥æ–‡ä»¶
      await fs.writeFile(filePath, content, "utf8");

      // Gitæ“ä½œ
      execSync(`git add "${fileId}"`, { cwd: this.repoPath });

      const commitMessage = `${message} (by ${userId})`;
      execSync(`git commit -m "${commitMessage}"`, { cwd: this.repoPath });

      // è·å–æäº¤å“ˆå¸Œ
      const hash = execSync("git rev-parse HEAD", {
        cwd: this.repoPath,
        encoding: "utf8",
      }).trim();

      return {
        success: true,
        hash,
        message: commitMessage,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      throw new Error(`Gitæäº¤å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * è·å–æ–‡ä»¶å†å²
   */
  async getFileHistory(fileId, limit = 20) {
    try {
      const command = `git log --oneline -n ${limit} --follow -- "${fileId}"`;
      const output = execSync(command, {
        cwd: this.repoPath,
        encoding: "utf8",
      });

      const commits = output
        .trim()
        .split("\n")
        .filter((line) => line.trim())
        .map((line) => {
          const [hash, ...messageParts] = line.split(" ");
          return {
            hash,
            message: messageParts.join(" "),
            shortHash: hash.substring(0, 7),
          };
        });

      return commits;
    } catch (error) {
      if (error.message.includes("does not exist")) {
        return [];
      }
      throw new Error(`è·å–æ–‡ä»¶å†å²å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * è·å–ä¸¤ä¸ªç‰ˆæœ¬é—´çš„å·®å¼‚
   */
  async getDiff(fileId, fromHash, toHash = "HEAD") {
    try {
      const command = `git diff ${fromHash}..${toHash} -- "${fileId}"`;
      const diff = execSync(command, {
        cwd: this.repoPath,
        encoding: "utf8",
      });

      return this.parseDiff(diff);
    } catch (error) {
      throw new Error(`è·å–å·®å¼‚å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * è§£æGitå·®å¼‚
   */
  parseDiff(diffText) {
    const lines = diffText.split("\n");
    const changes = [];
    let currentHunk = null;

    for (const line of lines) {
      if (line.startsWith("@@")) {
        // æ–°çš„å·®å¼‚å—
        const match = line.match(/@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@/);
        if (match) {
          currentHunk = {
            oldStart: parseInt(match[1]),
            oldLines: parseInt(match[2] || "1"),
            newStart: parseInt(match[3]),
            newLines: parseInt(match[4] || "1"),
            changes: [],
          };
          changes.push(currentHunk);
        }
      } else if (
        currentHunk &&
        (line.startsWith("+") || line.startsWith("-") || line.startsWith(" "))
      ) {
        currentHunk.changes.push({
          type:
            line[0] === "+" ? "add" : line[0] === "-" ? "delete" : "context",
          content: line.substring(1),
          lineNumber:
            line[0] === "-"
              ? currentHunk.oldStart++
              : line[0] === "+"
              ? currentHunk.newStart++
              : currentHunk.oldStart++,
        });
      }
    }

    return changes;
  }

  /**
   * è·å–ç‰¹å®šç‰ˆæœ¬çš„æ–‡ä»¶å†…å®¹
   */
  async getFileContent(fileId, hash = "HEAD") {
    try {
      const content = execSync(`git show ${hash}:"${fileId}"`, {
        cwd: this.repoPath,
        encoding: "utf8",
      });

      return content;
    } catch (error) {
      if (error.message.includes("does not exist")) {
        return null;
      }
      throw new Error(`è·å–æ–‡ä»¶å†…å®¹å¤±è´¥: ${error.message}`);
    }
  }
}

export default GitManager;
```

## å¯è§†åŒ–å·®å¼‚å¼•æ“

### å·®å¼‚è®¡ç®—å™¨

```javascript
// DiffCalculator.js
class DiffCalculator {
  /**
   * Myerså·®å¼‚ç®—æ³•å®ç°
   */
  static calculateDiff(oldText, newText) {
    const oldLines = oldText.split("\n");
    const newLines = newText.split("\n");

    const diff = this.myersDiff(oldLines, newLines);
    return this.formatDiff(diff, oldLines, newLines);
  }

  /**
   * Myersç®—æ³•æ ¸å¿ƒå®ç°
   */
  static myersDiff(a, b) {
    const N = a.length;
    const M = b.length;
    const MAX = N + M;

    const v = {};
    const trace = [];

    v[1] = 0;

    for (let d = 0; d <= MAX; d++) {
      trace.push({ ...v });

      for (let k = -d; k <= d; k += 2) {
        let x;

        if (k === -d || (k !== d && v[k - 1] < v[k + 1])) {
          x = v[k + 1];
        } else {
          x = v[k - 1] + 1;
        }

        let y = x - k;

        while (x < N && y < M && a[x] === b[y]) {
          x++;
          y++;
        }

        v[k] = x;

        if (x >= N && y >= M) {
          return this.backtrack(trace, a, b, x, y, d);
        }
      }
    }

    return [];
  }

  /**
   * å›æº¯æ„å»ºå·®å¼‚è·¯å¾„
   */
  static backtrack(trace, a, b, x, y, d) {
    const path = [];

    for (let i = d; i >= 0; i--) {
      const v = trace[i];
      const k = x - y;

      let prevK;
      if (k === -i || (k !== i && v[k - 1] < v[k + 1])) {
        prevK = k + 1;
      } else {
        prevK = k - 1;
      }

      const prevX = v[prevK];
      const prevY = prevX - prevK;

      while (x > prevX && y > prevY) {
        path.unshift({ type: "equal", oldIndex: x - 1, newIndex: y - 1 });
        x--;
        y--;
      }

      if (i > 0) {
        if (x > prevX) {
          path.unshift({ type: "delete", oldIndex: x - 1, newIndex: -1 });
          x--;
        } else {
          path.unshift({ type: "insert", oldIndex: -1, newIndex: y - 1 });
          y--;
        }
      }
    }

    return path;
  }

  /**
   * æ ¼å¼åŒ–å·®å¼‚ç»“æœ
   */
  static formatDiff(path, oldLines, newLines) {
    const result = {
      additions: 0,
      deletions: 0,
      changes: [],
    };

    let currentChange = null;

    for (const step of path) {
      if (step.type === "equal") {
        if (currentChange) {
          result.changes.push(currentChange);
          currentChange = null;
        }

        result.changes.push({
          type: "equal",
          content: oldLines[step.oldIndex],
          oldLineNumber: step.oldIndex + 1,
          newLineNumber: step.newIndex + 1,
        });
      } else if (step.type === "delete") {
        if (!currentChange) {
          currentChange = {
            type: "change",
            deletions: [],
            additions: [],
          };
        }

        currentChange.deletions.push({
          content: oldLines[step.oldIndex],
          lineNumber: step.oldIndex + 1,
        });

        result.deletions++;
      } else if (step.type === "insert") {
        if (!currentChange) {
          currentChange = {
            type: "change",
            deletions: [],
            additions: [],
          };
        }

        currentChange.additions.push({
          content: newLines[step.newIndex],
          lineNumber: step.newIndex + 1,
        });

        result.additions++;
      }
    }

    if (currentChange) {
      result.changes.push(currentChange);
    }

    return result;
  }

  /**
   * è®¡ç®—ç›¸ä¼¼åº¦
   */
  static calculateSimilarity(oldText, newText) {
    const oldLines = oldText.split("\n");
    const newLines = newText.split("\n");

    const diff = this.calculateDiff(oldText, newText);
    const totalLines = Math.max(oldLines.length, newLines.length);
    const changedLines = diff.additions + diff.deletions;

    return Math.max(0, (totalLines - changedLines) / totalLines);
  }
}

export default DiffCalculator;
```

### å‰ç«¯å·®å¼‚ç»„ä»¶

```javascript
// DiffViewer.jsx
import React, { useMemo } from "react";
import "./DiffViewer.css";

const DiffViewer = ({ oldContent, newContent, title }) => {
  const diffResult = useMemo(() => {
    return DiffCalculator.calculateDiff(oldContent, newContent);
  }, [oldContent, newContent]);

  const similarity = useMemo(() => {
    return DiffCalculator.calculateSimilarity(oldContent, newContent);
  }, [oldContent, newContent]);

  const renderChange = (change, index) => {
    if (change.type === "equal") {
      return (
        <div key={index} className="diff-line diff-equal">
          <span className="line-number old">{change.oldLineNumber}</span>
          <span className="line-number new">{change.newLineNumber}</span>
          <span className="line-content">{change.content}</span>
        </div>
      );
    }

    if (change.type === "change") {
      return (
        <div key={index} className="diff-change-group">
          {change.deletions.map((deletion, i) => (
            <div key={`del-${i}`} className="diff-line diff-deletion">
              <span className="line-number old">{deletion.lineNumber}</span>
              <span className="line-number new">-</span>
              <span className="line-content">- {deletion.content}</span>
            </div>
          ))}
          {change.additions.map((addition, i) => (
            <div key={`add-${i}`} className="diff-line diff-addition">
              <span className="line-number old">-</span>
              <span className="line-number new">{addition.lineNumber}</span>
              <span className="line-content">+ {addition.content}</span>
            </div>
          ))}
        </div>
      );
    }

    return null;
  };

  return (
    <div className="diff-viewer">
      <div className="diff-header">
        <h3>{title}</h3>
        <div className="diff-stats">
          <span className="additions">+{diffResult.additions}</span>
          <span className="deletions">-{diffResult.deletions}</span>
          <span className="similarity">
            ç›¸ä¼¼åº¦: {(similarity * 100).toFixed(1)}%
          </span>
        </div>
      </div>

      <div className="diff-content">
        <div className="diff-header-row">
          <span className="line-number-header">æ—§ç‰ˆæœ¬</span>
          <span className="line-number-header">æ–°ç‰ˆæœ¬</span>
          <span className="content-header">å†…å®¹</span>
        </div>

        {diffResult.changes.map(renderChange)}
      </div>
    </div>
  );
};

export default DiffViewer;
```

## ä½¿ç”¨ç¤ºä¾‹

### å‰ç«¯é›†æˆ

```javascript
// CollaborativeEditor.jsx
import React, { useState, useEffect, useRef } from "react";
import { io } from "socket.io-client";
import MonacoEditor from "@monaco-editor/react";
import DiffViewer from "./DiffViewer";

const CollaborativeEditor = ({ fileId, userId, userInfo }) => {
  const [content, setContent] = useState("");
  const [isLocked, setIsLocked] = useState(false);
  const [lockOwner, setLockOwner] = useState(null);
  const [activeUsers, setActiveUsers] = useState([]);
  const [showDiff, setShowDiff] = useState(false);
  const [originalContent, setOriginalContent] = useState("");

  const socketRef = useRef(null);
  const editorRef = useRef(null);

  useEffect(() => {
    // å»ºç«‹WebSocketè¿æ¥
    socketRef.current = io("ws://localhost:3001");

    const socket = socketRef.current;

    // åŠ å…¥æ–‡ä»¶ç¼–è¾‘
    socket.emit("join-file", { fileId, userId, userInfo });

    // ç›‘å¬äº‹ä»¶
    socket.on("join-success", (data) => {
      setActiveUsers(data.activeUsers);
      if (data.lockStatus.locked) {
        setIsLocked(true);
        setLockOwner(data.lockStatus.userInfo);
      }
    });

    socket.on("lock-acquired", (data) => {
      setIsLocked(true);
      setLockOwner(data.userInfo);
    });

    socket.on("lock-released", () => {
      setIsLocked(false);
      setLockOwner(null);
    });

    socket.on("content-updated", (data) => {
      if (data.userId !== userId) {
        // åº”ç”¨å…¶ä»–ç”¨æˆ·çš„æ›´æ”¹
        applyChanges(data.changes);
      }
    });

    socket.on("file-saved", (data) => {
      console.log("æ–‡ä»¶å·²ä¿å­˜:", data);
      setOriginalContent(content);
    });

    return () => {
      socket.disconnect();
    };
  }, [fileId, userId]);

  const requestLock = () => {
    socketRef.current.emit("request-lock", {
      fileId,
      userId,
      userInfo,
    });
  };

  const releaseLock = () => {
    socketRef.current.emit("release-lock", {
      fileId,
      userId,
    });
  };

  const handleContentChange = (value) => {
    setContent(value);

    if (isLocked && lockOwner?.userId === userId) {
      // å‘é€å†…å®¹å˜æ›´
      socketRef.current.emit("content-change", {
        fileId,
        userId,
        changes: value,
        version: Date.now(),
      });
    }
  };

  const saveFile = () => {
    if (isLocked && lockOwner?.userId === userId) {
      const message = prompt("è¯·è¾“å…¥æäº¤ä¿¡æ¯:");
      if (message) {
        socketRef.current.emit("save-file", {
          fileId,
          userId,
          content,
          message,
        });
      }
    }
  };

  const applyChanges = (changes) => {
    if (editorRef.current) {
      const editor = editorRef.current;
      editor.setValue(changes);
    }
  };

  const toggleDiff = () => {
    setShowDiff(!showDiff);
  };

  return (
    <div className="collaborative-editor">
      <div className="editor-toolbar">
        <div className="lock-status">
          {isLocked ? (
            <span
              className={`lock-indicator locked ${
                lockOwner?.userId === userId ? "owned" : ""
              }`}
            >
              ğŸ”’{" "}
              {lockOwner?.userId === userId
                ? "ä½ æ­£åœ¨ç¼–è¾‘"
                : `${lockOwner?.name} æ­£åœ¨ç¼–è¾‘`}
            </span>
          ) : (
            <span className="lock-indicator unlocked">ğŸ”“ å¯ç¼–è¾‘</span>
          )}
        </div>

        <div className="editor-actions">
          {!isLocked && (
            <button onClick={requestLock} className="btn-primary">
              å¼€å§‹ç¼–è¾‘
            </button>
          )}

          {isLocked && lockOwner?.userId === userId && (
            <>
              <button onClick={saveFile} className="btn-success">
                ä¿å­˜
              </button>
              <button onClick={releaseLock} className="btn-secondary">
                ç»“æŸç¼–è¾‘
              </button>
            </>
          )}

          <button onClick={toggleDiff} className="btn-outline">
            {showDiff ? "éšè—å·®å¼‚" : "æ˜¾ç¤ºå·®å¼‚"}
          </button>
        </div>

        <div className="active-users">
          {activeUsers.map((user) => (
            <span
              key={user.userId}
              className="user-avatar"
              title={user.userInfo.name}
            >
              {user.userInfo.name[0]}
            </span>
          ))}
        </div>
      </div>

      {showDiff ? (
        <DiffViewer
          oldContent={originalContent}
          newContent={content}
          title="æ–‡ä»¶å·®å¼‚å¯¹æ¯”"
        />
      ) : (
        <MonacoEditor
          height="600px"
          language="javascript"
          value={content}
          onChange={handleContentChange}
          onMount={(editor) => {
            editorRef.current = editor;
          }}
          options={{
            readOnly: !isLocked || lockOwner?.userId !== userId,
            minimap: { enabled: false },
            scrollBeyondLastLine: false,
          }}
        />
      )}
    </div>
  );
};

export default CollaborativeEditor;
```

## æ ¸å¿ƒä¼˜åŠ¿

### 1. å†²çªé¿å…

- **ç¼–è¾‘é”å®š**: ç¡®ä¿åŒæ—¶åªæœ‰ä¸€äººç¼–è¾‘
- **å®æ—¶çŠ¶æ€**: æ˜¾ç¤ºæ–‡ä»¶ç¼–è¾‘çŠ¶æ€å’Œæ´»è·ƒç”¨æˆ·
- **è‡ªåŠ¨é‡Šæ”¾**: è¿æ¥æ–­å¼€æ—¶è‡ªåŠ¨é‡Šæ”¾é”å®š

### 2. ç‰ˆæœ¬ç®¡ç†

- **Git é›†æˆ**: å®Œæ•´çš„ç‰ˆæœ¬å†å²è®°å½•
- **æäº¤è¿½è¸ª**: è®°å½•æ¯æ¬¡ä¿®æ”¹çš„ä½œè€…å’Œæ—¶é—´
- **åˆ†æ”¯æ”¯æŒ**: æ”¯æŒå¤šåˆ†æ”¯å¼€å‘æµç¨‹

### 3. å¯è§†åŒ–å·®å¼‚

- **ç²¾ç¡®å¯¹æ¯”**: åŸºäº Myers ç®—æ³•çš„é«˜æ•ˆå·®å¼‚è®¡ç®—
- **ç›´è§‚å±•ç¤º**: æ¸…æ™°çš„å¢åˆ æ”¹æ ‡è¯†
- **ç›¸ä¼¼åº¦åˆ†æ**: é‡åŒ–æ–‡ä»¶å˜æ›´ç¨‹åº¦

### 4. å®æ—¶åä½œ

- **WebSocket é€šä¿¡**: ä½å»¶è¿Ÿçš„å®æ—¶åŒæ­¥
- **çŠ¶æ€åŒæ­¥**: ç¼–è¾‘çŠ¶æ€å’Œç”¨æˆ·æ´»åŠ¨å®æ—¶æ›´æ–°
- **ä¼˜é›…é™çº§**: ç½‘ç»œå¼‚å¸¸æ—¶çš„æœ¬åœ°ç¼“å­˜æœºåˆ¶

## æ€»ç»“

ååŒå¼€å‘ä¸ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿé€šè¿‡ç¼–è¾‘é”å®šæœºåˆ¶æœ‰æ•ˆé¿å…äº†å¤šäººç¼–è¾‘å†²çªï¼Œç»“åˆ Git ç‰ˆæœ¬ç®¡ç†å’Œå¯è§†åŒ–å·®å¼‚å·¥å…·ï¼Œä¸ºå›¢é˜Ÿæä¾›äº†å®Œæ•´çš„åä½œå¼€å‘è§£å†³æ–¹æ¡ˆã€‚è¯¥ç³»ç»Ÿä¸ä»…æå‡äº†å¼€å‘æ•ˆç‡ï¼Œè¿˜ä¿è¯äº†ä»£ç è´¨é‡å’Œç‰ˆæœ¬ç®¡ç†çš„è§„èŒƒæ€§ã€‚
