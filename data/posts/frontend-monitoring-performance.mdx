---
title: "前端监控与性能优化实战：构建完整的性能监控体系"
slug: "frontend-monitoring-performance"
excerpt: "深入探讨前端性能监控的完整解决方案，从数据采集到分析优化，构建企业级的性能监控体系。"
date: "2024-06-01"
published: true
category: "技术"
tags: ["性能监控", "前端开发", "性能优化"]
author: "hailong"
readingTime: 20
---

## 引言

在现代Web应用开发中，性能监控不再是可有可无的附加功能，而是保证用户体验和业务成功的关键基础设施。一个完善的前端监控体系能够帮助我们及时发现问题、定位瓶颈、优化性能，最终提升用户满意度和业务转化率。本文将从理论到实践，全面介绍如何构建一个企业级的前端性能监控体系。

## 性能监控的核心指标

### Web Vitals 核心指标

Google提出的Web Vitals为我们提供了衡量用户体验的标准化指标。

#### 1. Largest Contentful Paint (LCP)

```javascript
// LCP 监控实现
class LCPMonitor {
  constructor() {
    this.lcpValue = 0;
    this.lcpElement = null;
    this.observer = null;
    this.init();
  }
  
  init() {
    // 使用 PerformanceObserver 监控 LCP
    if ('PerformanceObserver' in window) {
      this.observer = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        const lastEntry = entries[entries.length - 1];
        
        this.lcpValue = lastEntry.startTime;
        this.lcpElement = lastEntry.element;
        
        // 发送数据到监控服务
        this.reportLCP({
          value: this.lcpValue,
          element: this.getElementSelector(lastEntry.element),
          url: window.location.href,
          timestamp: Date.now()
        });
      });
      
      this.observer.observe({ entryTypes: ['largest-contentful-paint'] });
    }
    
    // 页面隐藏时停止观察
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        this.observer?.disconnect();
      }
    });
  }
  
  getElementSelector(element) {
    if (!element) return null;
    
    // 生成元素选择器
    const path = [];
    let current = element;
    
    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();
      
      if (current.id) {
        selector += `#${current.id}`;
        path.unshift(selector);
        break;
      }
      
      if (current.className) {
        selector += `.${current.className.split(' ').join('.')}`;
      }
      
      path.unshift(selector);
      current = current.parentElement;
    }
    
    return path.join(' > ');
  }
  
  reportLCP(data) {
    // 发送到监控服务
    this.sendToAnalytics('lcp', data);
  }
  
  sendToAnalytics(metric, data) {
    // 使用 sendBeacon 确保数据发送
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/api/analytics', JSON.stringify({
        metric,
        data,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      }));
    }
  }
}
```

#### 2. First Input Delay (FID)

```javascript
// FID 监控实现
class FIDMonitor {
  constructor() {
    this.isFirstInput = true;
    this.init();
  }
  
  init() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        
        entries.forEach(entry => {
          if (this.isFirstInput) {
            this.isFirstInput = false;
            
            const fid = entry.processingStart - entry.startTime;
            
            this.reportFID({
              value: fid,
              eventType: entry.name,
              target: this.getElementInfo(entry.target),
              url: window.location.href,
              timestamp: Date.now()
            });
          }
        });
      });
      
      observer.observe({ entryTypes: ['first-input'] });
    }
  }
  
  getElementInfo(element) {
    if (!element) return null;
    
    return {
      tagName: element.tagName,
      id: element.id,
      className: element.className,
      textContent: element.textContent?.slice(0, 100)
    };
  }
  
  reportFID(data) {
    this.sendToAnalytics('fid', data);
  }
  
  sendToAnalytics(metric, data) {
    fetch('/api/analytics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ metric, data })
    }).catch(err => console.error('Analytics error:', err));
  }
}
```

#### 3. Cumulative Layout Shift (CLS)

```javascript
// CLS 监控实现
class CLSMonitor {
  constructor() {
    this.clsValue = 0;
    this.sessionValue = 0;
    this.sessionEntries = [];
    this.init();
  }
  
  init() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        
        entries.forEach(entry => {
          // 只统计非用户输入导致的布局偏移
          if (!entry.hadRecentInput) {
            this.sessionValue += entry.value;
            this.sessionEntries.push(entry);
            
            // 检查是否需要开始新的会话
            if (this.shouldStartNewSession(entry)) {
              this.clsValue = Math.max(this.clsValue, this.sessionValue);
              this.reportCLS({
                value: this.sessionValue,
                entries: this.sessionEntries.map(e => this.formatEntry(e)),
                url: window.location.href,
                timestamp: Date.now()
              });
              
              this.sessionValue = 0;
              this.sessionEntries = [];
            }
          }
        });
      });
      
      observer.observe({ entryTypes: ['layout-shift'] });
    }
    
    // 页面卸载时报告最终值
    window.addEventListener('beforeunload', () => {
      if (this.sessionValue > 0) {
        this.clsValue = Math.max(this.clsValue, this.sessionValue);
        this.reportCLS({
          value: this.sessionValue,
          entries: this.sessionEntries.map(e => this.formatEntry(e)),
          url: window.location.href,
          timestamp: Date.now(),
          final: true
        });
      }
    });
  }
  
  shouldStartNewSession(entry) {
    // 如果距离上次偏移超过1秒，或者总偏移超过5秒，开始新会话
    const lastEntry = this.sessionEntries[this.sessionEntries.length - 2];
    return lastEntry && 
           (entry.startTime - lastEntry.startTime > 1000 || 
            entry.startTime - this.sessionEntries[0].startTime > 5000);
  }
  
  formatEntry(entry) {
    return {
      value: entry.value,
      startTime: entry.startTime,
      sources: entry.sources?.map(source => ({
        node: this.getElementSelector(source.node),
        previousRect: source.previousRect,
        currentRect: source.currentRect
      }))
    };
  }
  
  getElementSelector(element) {
    // 与 LCP 监控中的实现相同
    // ...
  }
  
  reportCLS(data) {
    this.sendToAnalytics('cls', data);
  }
  
  sendToAnalytics(metric, data) {
    navigator.sendBeacon?.('/api/analytics', JSON.stringify({ metric, data }));
  }
}
```

### 自定义性能指标

#### 1. 资源加载监控

```javascript
// 资源加载性能监控
class ResourceMonitor {
  constructor() {
    this.init();
  }
  
  init() {
    // 监控现有资源
    this.monitorExistingResources();
    
    // 监控新加载的资源
    this.monitorNewResources();
  }
  
  monitorExistingResources() {
    const resources = performance.getEntriesByType('resource');
    
    resources.forEach(resource => {
      this.analyzeResource(resource);
    });
  }
  
  monitorNewResources() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        
        entries.forEach(entry => {
          this.analyzeResource(entry);
        });
      });
      
      observer.observe({ entryTypes: ['resource'] });
    }
  }
  
  analyzeResource(resource) {
    const analysis = {
      name: resource.name,
      type: this.getResourceType(resource),
      size: resource.transferSize,
      duration: resource.duration,
      timing: {
        dns: resource.domainLookupEnd - resource.domainLookupStart,
        tcp: resource.connectEnd - resource.connectStart,
        ssl: resource.secureConnectionStart > 0 ? 
             resource.connectEnd - resource.secureConnectionStart : 0,
        ttfb: resource.responseStart - resource.requestStart,
        download: resource.responseEnd - resource.responseStart
      },
      cache: this.getCacheStatus(resource),
      url: window.location.href,
      timestamp: Date.now()
    };
    
    // 检查是否有性能问题
    this.checkPerformanceIssues(analysis);
    
    this.reportResource(analysis);
  }
  
  getResourceType(resource) {
    const url = new URL(resource.name);
    const extension = url.pathname.split('.').pop()?.toLowerCase();
    
    const typeMap = {
      'js': 'script',
      'css': 'stylesheet',
      'png': 'image',
      'jpg': 'image',
      'jpeg': 'image',
      'gif': 'image',
      'svg': 'image',
      'webp': 'image',
      'woff': 'font',
      'woff2': 'font',
      'ttf': 'font',
      'eot': 'font'
    };
    
    return typeMap[extension] || 'other';
  }
  
  getCacheStatus(resource) {
    if (resource.transferSize === 0) {
      return 'cache';
    } else if (resource.transferSize < resource.decodedBodySize) {
      return 'compressed';
    } else {
      return 'network';
    }
  }
  
  checkPerformanceIssues(analysis) {
    const issues = [];
    
    // 检查大文件
    if (analysis.size > 1024 * 1024) { // 1MB
      issues.push({
        type: 'large_file',
        message: `Large file detected: ${(analysis.size / 1024 / 1024).toFixed(2)}MB`,
        severity: 'warning'
      });
    }
    
    // 检查慢速加载
    if (analysis.duration > 3000) { // 3秒
      issues.push({
        type: 'slow_loading',
        message: `Slow loading resource: ${analysis.duration.toFixed(2)}ms`,
        severity: 'error'
      });
    }
    
    // 检查DNS查询时间
    if (analysis.timing.dns > 200) {
      issues.push({
        type: 'slow_dns',
        message: `Slow DNS lookup: ${analysis.timing.dns.toFixed(2)}ms`,
        severity: 'warning'
      });
    }
    
    // 检查TTFB
    if (analysis.timing.ttfb > 800) {
      issues.push({
        type: 'slow_ttfb',
        message: `Slow TTFB: ${analysis.timing.ttfb.toFixed(2)}ms`,
        severity: 'warning'
      });
    }
    
    if (issues.length > 0) {
      this.reportIssues(analysis.name, issues);
    }
  }
  
  reportResource(data) {
    this.sendToAnalytics('resource', data);
  }
  
  reportIssues(resourceName, issues) {
    this.sendToAnalytics('performance_issues', {
      resource: resourceName,
      issues,
      url: window.location.href,
      timestamp: Date.now()
    });
  }
  
  sendToAnalytics(metric, data) {
    // 批量发送以减少请求数量
    this.batchSend(metric, data);
  }
  
  batchSend(metric, data) {
    if (!this.batch) {
      this.batch = [];
    }
    
    this.batch.push({ metric, data });
    
    // 每100条或5秒发送一次
    if (this.batch.length >= 100) {
      this.flushBatch();
    } else if (!this.batchTimer) {
      this.batchTimer = setTimeout(() => {
        this.flushBatch();
      }, 5000);
    }
  }
  
  flushBatch() {
    if (this.batch.length > 0) {
      fetch('/api/analytics/batch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(this.batch)
      }).catch(err => console.error('Batch analytics error:', err));
      
      this.batch = [];
    }
    
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
      this.batchTimer = null;
    }
  }
}
```

#### 2. 用户行为监控

```javascript
// 用户行为监控
class UserBehaviorMonitor {
  constructor() {
    this.sessionId = this.generateSessionId();
    this.pageLoadTime = Date.now();
    this.interactions = [];
    this.init();
  }
  
  init() {
    this.monitorClicks();
    this.monitorScrolling();
    this.monitorFormInteractions();
    this.monitorPageVisibility();
    this.monitorErrors();
  }
  
  generateSessionId() {
    return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }
  
  monitorClicks() {
    document.addEventListener('click', (event) => {
      const interaction = {
        type: 'click',
        target: this.getElementInfo(event.target),
        position: { x: event.clientX, y: event.clientY },
        timestamp: Date.now() - this.pageLoadTime
      };
      
      this.recordInteraction(interaction);
    }, { passive: true });
  }
  
  monitorScrolling() {
    let scrollTimer;
    let maxScroll = 0;
    
    window.addEventListener('scroll', () => {
      const scrollPercent = Math.round(
        (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100
      );
      
      maxScroll = Math.max(maxScroll, scrollPercent);
      
      clearTimeout(scrollTimer);
      scrollTimer = setTimeout(() => {
        this.recordInteraction({
          type: 'scroll',
          maxDepth: maxScroll,
          currentDepth: scrollPercent,
          timestamp: Date.now() - this.pageLoadTime
        });
      }, 150);
    }, { passive: true });
  }
  
  monitorFormInteractions() {
    document.addEventListener('input', (event) => {
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        this.recordInteraction({
          type: 'form_input',
          field: {
            name: event.target.name,
            type: event.target.type,
            id: event.target.id
          },
          timestamp: Date.now() - this.pageLoadTime
        });
      }
    }, { passive: true });
    
    document.addEventListener('submit', (event) => {
      this.recordInteraction({
        type: 'form_submit',
        form: {
          action: event.target.action,
          method: event.target.method,
          id: event.target.id
        },
        timestamp: Date.now() - this.pageLoadTime
      });
    });
  }
  
  monitorPageVisibility() {
    let visibilityStart = Date.now();
    
    document.addEventListener('visibilitychange', () => {
      const now = Date.now();
      
      if (document.visibilityState === 'hidden') {
        const visibleTime = now - visibilityStart;
        this.recordInteraction({
          type: 'page_hidden',
          visibleTime,
          timestamp: now - this.pageLoadTime
        });
      } else {
        visibilityStart = now;
        this.recordInteraction({
          type: 'page_visible',
          timestamp: now - this.pageLoadTime
        });
      }
    });
    
    // 页面卸载时记录会话时长
    window.addEventListener('beforeunload', () => {
      const sessionDuration = Date.now() - this.pageLoadTime;
      this.reportSession({
        sessionId: this.sessionId,
        duration: sessionDuration,
        interactions: this.interactions.length,
        url: window.location.href,
        timestamp: Date.now()
      });
    });
  }
  
  monitorErrors() {
    // JavaScript错误
    window.addEventListener('error', (event) => {
      this.recordError({
        type: 'javascript_error',
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack,
        timestamp: Date.now() - this.pageLoadTime
      });
    });
    
    // Promise拒绝
    window.addEventListener('unhandledrejection', (event) => {
      this.recordError({
        type: 'promise_rejection',
        reason: event.reason?.toString(),
        stack: event.reason?.stack,
        timestamp: Date.now() - this.pageLoadTime
      });
    });
    
    // 资源加载错误
    window.addEventListener('error', (event) => {
      if (event.target !== window) {
        this.recordError({
          type: 'resource_error',
          source: event.target.src || event.target.href,
          tagName: event.target.tagName,
          timestamp: Date.now() - this.pageLoadTime
        });
      }
    }, true);
  }
  
  getElementInfo(element) {
    return {
      tagName: element.tagName,
      id: element.id,
      className: element.className,
      textContent: element.textContent?.slice(0, 50),
      attributes: this.getRelevantAttributes(element)
    };
  }
  
  getRelevantAttributes(element) {
    const relevantAttrs = ['data-track', 'data-testid', 'role', 'aria-label'];
    const attrs = {};
    
    relevantAttrs.forEach(attr => {
      if (element.hasAttribute(attr)) {
        attrs[attr] = element.getAttribute(attr);
      }
    });
    
    return attrs;
  }
  
  recordInteraction(interaction) {
    this.interactions.push({
      ...interaction,
      sessionId: this.sessionId,
      url: window.location.href
    });
    
    // 实时发送重要交互
    if (['form_submit', 'error'].includes(interaction.type)) {
      this.sendToAnalytics('interaction', interaction);
    }
  }
  
  recordError(error) {
    this.sendToAnalytics('error', {
      ...error,
      sessionId: this.sessionId,
      url: window.location.href,
      userAgent: navigator.userAgent
    });
  }
  
  reportSession(sessionData) {
    this.sendToAnalytics('session', sessionData);
  }
  
  sendToAnalytics(metric, data) {
    navigator.sendBeacon?.('/api/analytics', JSON.stringify({ metric, data }));
  }
}
```

## 监控数据收集与处理

### 数据收集策略

```javascript
// 统一的监控数据收集器
class PerformanceCollector {
  constructor(config = {}) {
    this.config = {
      endpoint: '/api/analytics',
      batchSize: 50,
      flushInterval: 5000,
      enableSampling: true,
      samplingRate: 0.1, // 10%采样率
      ...config
    };
    
    this.queue = [];
    this.monitors = new Map();
    this.init();
  }
  
  init() {
    // 初始化各种监控器
    this.initMonitors();
    
    // 设置定时刷新
    this.setupFlushTimer();
    
    // 页面卸载时刷新队列
    window.addEventListener('beforeunload', () => {
      this.flush(true);
    });
  }
  
  initMonitors() {
    // 根据配置启用不同的监控器
    if (this.shouldCollect('vitals')) {
      this.monitors.set('lcp', new LCPMonitor());
      this.monitors.set('fid', new FIDMonitor());
      this.monitors.set('cls', new CLSMonitor());
    }
    
    if (this.shouldCollect('resources')) {
      this.monitors.set('resources', new ResourceMonitor());
    }
    
    if (this.shouldCollect('behavior')) {
      this.monitors.set('behavior', new UserBehaviorMonitor());
    }
    
    if (this.shouldCollect('navigation')) {
      this.monitors.set('navigation', new NavigationMonitor());
    }
  }
  
  shouldCollect(type) {
    // 采样控制
    if (this.config.enableSampling) {
      return Math.random() < this.config.samplingRate;
    }
    return true;
  }
  
  collect(metric, data) {
    // 数据预处理
    const processedData = this.preprocessData(metric, data);
    
    // 添加通用字段
    const enrichedData = {
      ...processedData,
      sessionId: this.getSessionId(),
      userId: this.getUserId(),
      timestamp: Date.now(),
      url: window.location.href,
      referrer: document.referrer,
      userAgent: navigator.userAgent,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight
      },
      connection: this.getConnectionInfo()
    };
    
    this.queue.push({
      metric,
      data: enrichedData
    });
    
    // 检查是否需要立即发送
    if (this.shouldFlushImmediately(metric)) {
      this.flush();
    } else if (this.queue.length >= this.config.batchSize) {
      this.flush();
    }
  }
  
  preprocessData(metric, data) {
    // 数据清理和标准化
    const processed = { ...data };
    
    // 移除敏感信息
    if (processed.url) {
      processed.url = this.sanitizeUrl(processed.url);
    }
    
    // 数值精度控制
    if (typeof processed.value === 'number') {
      processed.value = Math.round(processed.value * 100) / 100;
    }
    
    return processed;
  }
  
  sanitizeUrl(url) {
    try {
      const urlObj = new URL(url);
      // 移除敏感查询参数
      const sensitiveParams = ['token', 'key', 'password', 'secret'];
      
      sensitiveParams.forEach(param => {
        urlObj.searchParams.delete(param);
      });
      
      return urlObj.toString();
    } catch {
      return url;
    }
  }
  
  getConnectionInfo() {
    if ('connection' in navigator) {
      const conn = navigator.connection;
      return {
        effectiveType: conn.effectiveType,
        downlink: conn.downlink,
        rtt: conn.rtt,
        saveData: conn.saveData
      };
    }
    return null;
  }
  
  shouldFlushImmediately(metric) {
    // 错误和关键指标立即发送
    const immediateMetrics = ['error', 'crash', 'security_violation'];
    return immediateMetrics.includes(metric);
  }
  
  setupFlushTimer() {
    setInterval(() => {
      if (this.queue.length > 0) {
        this.flush();
      }
    }, this.config.flushInterval);
  }
  
  flush(isBeforeUnload = false) {
    if (this.queue.length === 0) return;
    
    const payload = {
      batch: [...this.queue],
      metadata: {
        timestamp: Date.now(),
        batchSize: this.queue.length,
        isBeforeUnload
      }
    };
    
    this.queue = [];
    
    if (isBeforeUnload && navigator.sendBeacon) {
      // 页面卸载时使用 sendBeacon
      navigator.sendBeacon(
        this.config.endpoint,
        JSON.stringify(payload)
      );
    } else {
      // 正常情况使用 fetch
      fetch(this.config.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload),
        keepalive: true
      }).catch(err => {
        console.error('Analytics flush error:', err);
        // 失败时重新加入队列
        this.queue.unshift(...payload.batch);
      });
    }
  }
  
  getSessionId() {
    if (!this.sessionId) {
      this.sessionId = sessionStorage.getItem('analytics_session_id');
      if (!this.sessionId) {
        this.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        sessionStorage.setItem('analytics_session_id', this.sessionId);
      }
    }
    return this.sessionId;
  }
  
  getUserId() {
    // 从cookie或localStorage获取用户ID
    return localStorage.getItem('user_id') || 'anonymous';
  }
}
```

### 服务端数据处理

```javascript
// Node.js 服务端数据处理
const express = require('express');
const { InfluxDB, Point } = require('@influxdata/influxdb-client');
const redis = require('redis');

class AnalyticsServer {
  constructor() {
    this.app = express();
    this.influxDB = new InfluxDB({
      url: process.env.INFLUX_URL,
      token: process.env.INFLUX_TOKEN
    });
    this.writeApi = this.influxDB.getWriteApi(
      process.env.INFLUX_ORG,
      process.env.INFLUX_BUCKET
    );
    this.redis = redis.createClient();
    
    this.setupRoutes();
    this.setupMiddleware();
  }
  
  setupMiddleware() {
    this.app.use(express.json({ limit: '10mb' }));
    this.app.use(this.rateLimitMiddleware.bind(this));
    this.app.use(this.validationMiddleware.bind(this));
  }
  
  setupRoutes() {
    // 单条数据接收
    this.app.post('/api/analytics', this.handleSingleMetric.bind(this));
    
    // 批量数据接收
    this.app.post('/api/analytics/batch', this.handleBatchMetrics.bind(this));
    
    // 健康检查
    this.app.get('/api/analytics/health', this.healthCheck.bind(this));
  }
  
  async rateLimitMiddleware(req, res, next) {
    const clientIP = req.ip;
    const key = `rate_limit:${clientIP}`;
    
    try {
      const current = await this.redis.incr(key);
      if (current === 1) {
        await this.redis.expire(key, 60); // 1分钟窗口
      }
      
      if (current > 1000) { // 每分钟最多1000请求
        return res.status(429).json({ error: 'Rate limit exceeded' });
      }
      
      next();
    } catch (error) {
      console.error('Rate limit error:', error);
      next(); // 出错时不阻塞请求
    }
  }
  
  validationMiddleware(req, res, next) {
    // 验证请求格式
    if (!req.body || typeof req.body !== 'object') {
      return res.status(400).json({ error: 'Invalid request body' });
    }
    
    next();
  }
  
  async handleSingleMetric(req, res) {
    try {
      const { metric, data } = req.body;
      
      if (!metric || !data) {
        return res.status(400).json({ error: 'Missing metric or data' });
      }
      
      await this.processMetric(metric, data);
      res.status(200).json({ success: true });
    } catch (error) {
      console.error('Single metric error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }
  
  async handleBatchMetrics(req, res) {
    try {
      const { batch, metadata } = req.body;
      
      if (!Array.isArray(batch)) {
        return res.status(400).json({ error: 'Invalid batch format' });
      }
      
      // 并行处理批量数据
      const promises = batch.map(item => 
        this.processMetric(item.metric, item.data)
      );
      
      await Promise.allSettled(promises);
      
      res.status(200).json({ 
        success: true, 
        processed: batch.length 
      });
    } catch (error) {
      console.error('Batch metrics error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }
  
  async processMetric(metric, data) {
    // 数据验证和清理
    const cleanData = this.sanitizeData(data);
    
    // 写入时序数据库
    await this.writeToInfluxDB(metric, cleanData);
    
    // 实时告警检查
    await this.checkAlerts(metric, cleanData);
    
    // 更新实时统计
    await this.updateRealTimeStats(metric, cleanData);
  }
  
  sanitizeData(data) {
    const sanitized = { ...data };
    
    // 移除或脱敏敏感字段
    delete sanitized.userAgent;
    delete sanitized.ip;
    
    // 数据类型转换
    if (sanitized.value && typeof sanitized.value === 'string') {
      sanitized.value = parseFloat(sanitized.value) || 0;
    }
    
    return sanitized;
  }
  
  async writeToInfluxDB(metric, data) {
    const point = new Point(metric)
      .timestamp(new Date(data.timestamp))
      .tag('url', data.url)
      .tag('sessionId', data.sessionId)
      .tag('userId', data.userId);
    
    // 根据指标类型添加不同的字段
    switch (metric) {
      case 'lcp':
        point.floatField('value', data.value)
             .stringField('element', data.element);
        break;
        
      case 'fid':
        point.floatField('value', data.value)
             .stringField('eventType', data.eventType);
        break;
        
      case 'cls':
        point.floatField('value', data.value)
             .intField('entryCount', data.entries?.length || 0);
        break;
        
      case 'resource':
        point.floatField('duration', data.duration)
             .floatField('size', data.size)
             .stringField('type', data.type)
             .stringField('cache', data.cache);
        break;
        
      default:
        // 通用字段处理
        Object.entries(data).forEach(([key, value]) => {
          if (typeof value === 'number') {
            point.floatField(key, value);
          } else if (typeof value === 'string') {
            point.stringField(key, value);
          }
        });
    }
    
    this.writeApi.writePoint(point);
  }
  
  async checkAlerts(metric, data) {
    const alertRules = {
      lcp: { threshold: 2500, severity: 'warning' },
      fid: { threshold: 100, severity: 'warning' },
      cls: { threshold: 0.1, severity: 'warning' },
      error: { threshold: 1, severity: 'error' }
    };
    
    const rule = alertRules[metric];
    if (!rule) return;
    
    const value = data.value || 0;
    if (value > rule.threshold) {
      await this.triggerAlert({
        metric,
        value,
        threshold: rule.threshold,
        severity: rule.severity,
        url: data.url,
        timestamp: data.timestamp
      });
    }
  }
  
  async triggerAlert(alert) {
    // 发送到告警系统
    console.log('Alert triggered:', alert);
    
    // 这里可以集成钉钉、企业微信、邮件等告警渠道
    // await this.sendToSlack(alert);
    // await this.sendEmail(alert);
  }
  
  async updateRealTimeStats(metric, data) {
    const key = `stats:${metric}:${new Date().toISOString().slice(0, 13)}`; // 按小时统计
    
    await this.redis.hincrby(key, 'count', 1);
    
    if (data.value) {
      await this.redis.hincrbyfloat(key, 'sum', data.value);
    }
    
    await this.redis.expire(key, 86400); // 24小时过期
  }
  
  async healthCheck(req, res) {
    try {
      // 检查数据库连接
      await this.influxDB.ping();
      
      // 检查Redis连接
      await this.redis.ping();
      
      res.status(200).json({ 
        status: 'healthy',
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({ 
        status: 'unhealthy',
        error: error.message
      });
    }
  }
  
  start(port = 3001) {
    this.app.listen(port, () => {
      console.log(`Analytics server running on port ${port}`);
    });
  }
}

// 启动服务器
const server = new AnalyticsServer();
server.start();
```

## 数据可视化与分析

### 实时监控面板

```javascript
// React 监控面板组件
import React, { useState, useEffect } from 'react';
import { Line, Bar, Pie } from 'react-chartjs-2';
import io from 'socket.io-client';

const PerformanceDashboard = () => {
  const [metrics, setMetrics] = useState({
    vitals: { lcp: 0, fid: 0, cls: 0 },
    resources: [],
    errors: [],
    realTimeUsers: 0
  });
  
  const [timeRange, setTimeRange] = useState('1h');
  const [socket, setSocket] = useState(null);
  
  useEffect(() => {
    // 建立WebSocket连接获取实时数据
    const newSocket = io('/analytics');
    setSocket(newSocket);
    
    newSocket.on('metrics_update', (data) => {
      setMetrics(prev => ({
        ...prev,
        ...data
      }));
    });
    
    // 获取历史数据
    fetchHistoricalData(timeRange);
    
    return () => newSocket.close();
  }, [timeRange]);
  
  const fetchHistoricalData = async (range) => {
    try {
      const response = await fetch(`/api/analytics/dashboard?range=${range}`);
      const data = await response.json();
      setMetrics(prev => ({ ...prev, ...data }));
    } catch (error) {
      console.error('Failed to fetch historical data:', error);
    }
  };
  
  const vitalsChartData = {
    labels: ['LCP', 'FID', 'CLS'],
    datasets: [{
      label: 'Core Web Vitals',
      data: [
        metrics.vitals.lcp,
        metrics.vitals.fid,
        metrics.vitals.cls * 1000 // CLS转换为毫秒显示
      ],
      backgroundColor: [
        metrics.vitals.lcp > 2500 ? '#ff6b6b' : '#51cf66',
        metrics.vitals.fid > 100 ? '#ff6b6b' : '#51cf66',
        metrics.vitals.cls > 0.1 ? '#ff6b6b' : '#51cf66'
      ]
    }]
  };
  
  const resourceTypeData = {
    labels: ['JavaScript', 'CSS', 'Images', 'Fonts', 'Other'],
    datasets: [{
      data: [
        metrics.resources.filter(r => r.type === 'script').length,
        metrics.resources.filter(r => r.type === 'stylesheet').length,
        metrics.resources.filter(r => r.type === 'image').length,
        metrics.resources.filter(r => r.type === 'font').length,
        metrics.resources.filter(r => r.type === 'other').length
      ],
      backgroundColor: ['#ff9f43', '#10ac84', '#ee5a24', '#0abde3', '#5f27cd']
    }]
  };
  
  return (
    <div className="dashboard">
      <header className="dashboard-header">
        <h1>Performance Monitoring Dashboard</h1>
        <div className="time-range-selector">
          <select 
            value={timeRange} 
            onChange={(e) => setTimeRange(e.target.value)}
          >
            <option value="1h">Last Hour</option>
            <option value="24h">Last 24 Hours</option>
            <option value="7d">Last 7 Days</option>
            <option value="30d">Last 30 Days</option>
          </select>
        </div>
      </header>
      
      <div className="metrics-grid">
        {/* 核心指标卡片 */}
        <div className="metric-card">
          <h3>Real-time Users</h3>
          <div className="metric-value">{metrics.realTimeUsers}</div>
        </div>
        
        <div className="metric-card">
          <h3>LCP (ms)</h3>
          <div className={`metric-value ${metrics.vitals.lcp > 2500 ? 'warning' : 'good'}`}>
            {metrics.vitals.lcp.toFixed(0)}
          </div>
        </div>
        
        <div className="metric-card">
          <h3>FID (ms)</h3>
          <div className={`metric-value ${metrics.vitals.fid > 100 ? 'warning' : 'good'}`}>
            {metrics.vitals.fid.toFixed(0)}
          </div>
        </div>
        
        <div className="metric-card">
          <h3>CLS</h3>
          <div className={`metric-value ${metrics.vitals.cls > 0.1 ? 'warning' : 'good'}`}>
            {metrics.vitals.cls.toFixed(3)}
          </div>
        </div>
      </div>
      
      <div className="charts-grid">
        {/* Core Web Vitals 图表 */}
        <div className="chart-container">
          <h3>Core Web Vitals</h3>
          <Bar data={vitalsChartData} options={{
            responsive: true,
            scales: {
              y: {
                beginAtZero: true
              }
            }
          }} />
        </div>
        
        {/* 资源类型分布 */}
        <div className="chart-container">
          <h3>Resource Types</h3>
          <Pie data={resourceTypeData} options={{
            responsive: true,
            plugins: {
              legend: {
                position: 'bottom'
              }
            }
          }} />
        </div>
        
        {/* 错误趋势 */}
        <div className="chart-container full-width">
          <h3>Error Trends</h3>
          <ErrorTrendChart errors={metrics.errors} timeRange={timeRange} />
        </div>
        
        {/* 性能瀑布图 */}
        <div className="chart-container full-width">
          <h3>Resource Loading Waterfall</h3>
          <ResourceWaterfall resources={metrics.resources} />
        </div>
      </div>
      
      {/* 告警列表 */}
      <div className="alerts-section">
        <h3>Recent Alerts</h3>
        <AlertsList />
      </div>
    </div>
  );
};

export default PerformanceDashboard;
```

## 性能优化建议系统

```javascript
// 智能性能优化建议系统
class PerformanceOptimizer {
  constructor(analyticsData) {
    this.data = analyticsData;
    this.suggestions = [];
  }
  
  analyze() {
    this.analyzeLCP();
    this.analyzeFID();
    this.analyzeCLS();
    this.analyzeResources();
    this.analyzeErrors();
    
    return this.generateReport();
  }
  
  analyzeLCP() {
    const avgLCP = this.data.vitals.lcp.average;
    
    if (avgLCP > 4000) {
      this.suggestions.push({
        type: 'critical',
        metric: 'LCP',
        issue: 'Poor Largest Contentful Paint',
        value: avgLCP,
        threshold: 2500,
        impact: 'high',
        suggestions: [
          'Optimize server response times (TTFB)',
          'Implement resource preloading for critical assets',
          'Optimize and compress images',
          'Remove render-blocking resources',
          'Use a CDN for static assets'
        ],
        codeExamples: [
          {
            title: 'Preload critical resources',
            code: `<link rel="preload" href="/critical.css" as="style">
<link rel="preload" href="/hero-image.jpg" as="image">`
          },
          {
            title: 'Optimize images with modern formats',
            code: `<picture>
  <source srcset="image.webp" type="image/webp">
  <source srcset="image.avif" type="image/avif">
  <img src="image.jpg" alt="Description">
</picture>`
          }
        ]
      });
    } else if (avgLCP > 2500) {
      this.suggestions.push({
        type: 'warning',
        metric: 'LCP',
        issue: 'Needs improvement for LCP',
        value: avgLCP,
        threshold: 2500,
        impact: 'medium',
        suggestions: [
          'Optimize critical rendering path',
          'Implement lazy loading for non-critical images',
          'Minify CSS and JavaScript',
          'Enable text compression (gzip/brotli)'
        ]
      });
    }
  }
  
  analyzeFID() {
    const avgFID = this.data.vitals.fid.average;
    
    if (avgFID > 300) {
      this.suggestions.push({
        type: 'critical',
        metric: 'FID',
        issue: 'Poor First Input Delay',
        value: avgFID,
        threshold: 100,
        impact: 'high',
        suggestions: [
          'Break up long-running JavaScript tasks',
          'Implement code splitting and lazy loading',
          'Use web workers for heavy computations',
          'Optimize third-party scripts',
          'Defer non-critical JavaScript'
        ],
        codeExamples: [
          {
            title: 'Break up long tasks with scheduler.postTask',
            code: `function processLargeArray(array) {
  const chunkSize = 100;
  let index = 0;
  
  function processChunk() {
    const endIndex = Math.min(index + chunkSize, array.length);
    
    for (let i = index; i < endIndex; i++) {
      // Process array[i]
    }
    
    index = endIndex;
    
    if (index < array.length) {
      scheduler.postTask(processChunk, { priority: 'user-blocking' });
    }
  }
  
  processChunk();
}`
          }
        ]
      });
    }
  }
  
  analyzeCLS() {
    const avgCLS = this.data.vitals.cls.average;
    
    if (avgCLS > 0.25) {
      this.suggestions.push({
        type: 'critical',
        metric: 'CLS',
        issue: 'Poor Cumulative Layout Shift',
        value: avgCLS,
        threshold: 0.1,
        impact: 'high',
        suggestions: [
          'Set explicit dimensions for images and videos',
          'Reserve space for dynamic content',
          'Avoid inserting content above existing content',
          'Use CSS aspect-ratio for responsive images',
          'Preload fonts to prevent FOIT/FOUT'
        ],
        codeExamples: [
          {
            title: 'Reserve space with aspect-ratio',
            code: `.image-container {
  aspect-ratio: 16 / 9;
  width: 100%;
}

.image-container img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}`
          },
          {
            title: 'Preload fonts',
            code: `<link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>`
          }
        ]
      });
    }
  }
  
  analyzeResources() {
    const resources = this.data.resources;
    
    // 分析大文件
    const largeFiles = resources.filter(r => r.size > 1024 * 1024); // > 1MB
    if (largeFiles.length > 0) {
      this.suggestions.push({
        type: 'warning',
        metric: 'Resources',
        issue: 'Large resource files detected',
        impact: 'medium',
        details: largeFiles.map(f => `${f.name}: ${(f.size / 1024 / 1024).toFixed(2)}MB`),
        suggestions: [
          'Implement code splitting for JavaScript bundles',
          'Compress images and use modern formats',
          'Enable gzip/brotli compression',
          'Consider lazy loading for non-critical resources'
        ]
      });
    }
    
    // 分析慢速资源
    const slowResources = resources.filter(r => r.duration > 3000); // > 3s
    if (slowResources.length > 0) {
      this.suggestions.push({
        type: 'warning',
        metric: 'Resources',
        issue: 'Slow loading resources',
        impact: 'medium',
        details: slowResources.map(r => `${r.name}: ${r.duration.toFixed(0)}ms`),
        suggestions: [
          'Use a CDN for static assets',
          'Optimize server response times',
          'Implement resource preloading',
          'Consider using a faster hosting provider'
        ]
      });
    }
    
    // 分析未缓存的资源
    const uncachedResources = resources.filter(r => r.cache === 'network');
    if (uncachedResources.length > resources.length * 0.5) {
      this.suggestions.push({
        type: 'warning',
        metric: 'Caching',
        issue: 'Poor caching strategy',
        impact: 'medium',
        suggestions: [
          'Implement proper cache headers',
          'Use service workers for caching',
          'Enable browser caching for static assets',
          'Implement cache busting for updated resources'
        ],
        codeExamples: [
          {
            title: 'Service Worker caching strategy',
            code: `// sw.js
self.addEventListener('fetch', event => {
  if (event.request.destination === 'image') {
    event.respondWith(
      caches.open('images').then(cache => {
        return cache.match(event.request).then(response => {
          return response || fetch(event.request).then(fetchResponse => {
            cache.put(event.request, fetchResponse.clone());
            return fetchResponse;
          });
        });
      })
    );
  }
});`
          }
        ]
      });
    }
  }
  
  analyzeErrors() {
    const errors = this.data.errors;
    const errorRate = errors.length / this.data.totalPageViews;
    
    if (errorRate > 0.05) { // 5% 错误率
      const commonErrors = this.groupErrorsByType(errors);
      
      this.suggestions.push({
        type: 'critical',
        metric: 'Errors',
        issue: 'High error rate detected',
        value: `${(errorRate * 100).toFixed(2)}%`,
        impact: 'high',
        details: Object.entries(commonErrors)
          .sort(([,a], [,b]) => b - a)
          .slice(0, 5)
          .map(([error, count]) => `${error}: ${count} occurrences`),
        suggestions: [
          'Implement comprehensive error handling',
          'Add error boundaries in React applications',
          'Use try-catch blocks for risky operations',
          'Implement graceful degradation',
          'Add proper input validation'
        ]
      });
    }
  }
  
  groupErrorsByType(errors) {
    return errors.reduce((acc, error) => {
      const key = error.message || error.type || 'Unknown error';
      acc[key] = (acc[key] || 0) + 1;
      return acc;
    }, {});
  }
  
  generateReport() {
    // 按影响程度排序
    const sortedSuggestions = this.suggestions.sort((a, b) => {
      const impactOrder = { high: 3, medium: 2, low: 1 };
      const typeOrder = { critical: 3, warning: 2, info: 1 };
      
      return (impactOrder[b.impact] + typeOrder[b.type]) - 
             (impactOrder[a.impact] + typeOrder[a.type]);
    });
    
    return {
      summary: {
        totalIssues: this.suggestions.length,
        criticalIssues: this.suggestions.filter(s => s.type === 'critical').length,
        warningIssues: this.suggestions.filter(s => s.type === 'warning').length,
        overallScore: this.calculateOverallScore()
      },
      suggestions: sortedSuggestions,
      generatedAt: new Date().toISOString()
    };
  }
  
  calculateOverallScore() {
    // 基于Core Web Vitals计算总体评分
    const lcpScore = this.data.vitals.lcp.average <= 2500 ? 100 : 
                    this.data.vitals.lcp.average <= 4000 ? 50 : 0;
    const fidScore = this.data.vitals.fid.average <= 100 ? 100 : 
                    this.data.vitals.fid.average <= 300 ? 50 : 0;
    const clsScore = this.data.vitals.cls.average <= 0.1 ? 100 : 
                    this.data.vitals.cls.average <= 0.25 ? 50 : 0;
    
    return Math.round((lcpScore + fidScore + clsScore) / 3);
  }
}

// 使用示例
const optimizer = new PerformanceOptimizer(analyticsData);
const report = optimizer.analyze();
console.log('Performance optimization report:', report);
```

## 总结

构建完整的前端性能监控体系需要从多个维度考虑：

### 1. 监控指标体系
- **Core Web Vitals**：LCP、FID、CLS等用户体验核心指标
- **自定义指标**：业务相关的性能指标
- **资源监控**：加载时间、文件大小、缓存效果
- **错误监控**：JavaScript错误、资源加载失败
- **用户行为**：交互路径、停留时间、转化率

### 2. 数据收集策略
- **采样控制**：避免过度收集影响性能
- **批量发送**：减少网络请求开销
- **数据清理**：保护用户隐私，移除敏感信息
- **容错处理**：确保监控系统不影响主业务功能

### 3. 数据存储与分析
- **时序数据库**：使用InfluxDB等专业时序数据库
- **实时处理**：Redis等内存数据库支持实时统计
- **数据可视化**：构建直观的监控面板
- **智能告警**：基于阈值和趋势的告警机制

### 4. 性能优化闭环
- **问题发现**：通过监控数据及时发现性能问题
- **根因分析**：结合多维度数据定位问题根源
- **优化建议**：基于数据分析提供具体的优化方案
- **效果验证**：通过监控数据验证优化效果

### 5. 最佳实践建议

#### 监控实施策略
1. **渐进式部署**：从核心指标开始，逐步完善监控体系
2. **业务导向**：关注对业务影响最大的性能指标
3. **用户视角**：以真实用户体验为优化目标
4. **持续改进**：定期回顾和优化监控策略

#### 技术选型建议
1. **前端监控**：优先选择轻量级、高性能的监控SDK
2. **数据存储**：根据数据量和查询需求选择合适的存储方案
3. **可视化工具**：选择支持实时更新和自定义的可视化平台
4. **告警系统**：集成多种告警渠道，确保及时响应

通过构建完整的前端性能监控体系，我们能够：
- 及时发现和解决性能问题
- 持续优化用户体验
- 提升业务转化率
- 建立数据驱动的优化文化

性能监控不是一次性的工作，而是需要持续投入和优化的长期过程。只有建立了完善的监控体系，才能在激烈的市场竞争中保持技术优势，为用户提供更好的产品体验。